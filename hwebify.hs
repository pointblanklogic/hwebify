--
--
--          ***  HWEBIFY  ***
--
--   Pushing for great documentations!
--
--             Imagined by
--
--          POINT BLANK Logic.
--       www.pointblanklogic.com
--
--
--         seeded in April 2025
--            GPL Licensed.
--  ---
--  Initial commit: raw code of a first rough version of the idea.
--

import System.IO
import System.Environment (getArgs)
import System.Directory
import System.FilePath
import Control.Exception (bracket, catch, IOException)

import Control.Monad
import Control.Monad.IO.Class (liftIO)




processDirectory :: FilePath -> FilePath -> IO [FilePath]
processDirectory sourcePath destPath = do
  -- Get the list of files and directories in the source directory
  contents <- listDirectory sourcePath
--  paths <- forM_ contents $ \name -> do
  paths <- forM contents $ \name -> do
    let source = sourcePath </> name
    let dest = destPath </> name
    isDir <- doesDirectoryExist source
    if isDir
      then do
        -- create the corresponding directory in the destination
        createDirectoryIfMissing True dest
        -- Add this directory name to the variable holding all the data
        --   for the index creation at the end of this recursive journey
        --   down the directory tree.
        --   Recursively process the subdirectory
        processDirectory source dest
      else do
        putStrLn "Do something with the file."
--        process_file name
        processFile source dest
--        return [dest]
  return (concat paths)  -- To participate in the creation
                         -- of the list of files.
                         -- The comment generated by ai was:
                         -- "Flatten the list of lists"



processFile :: FilePath -> FilePath -> IO [FilePath]
processFile sourcePath destPath = do
  -- Process only if it's a text file
--  if (takeExtension sourcePath == ".txt") then do
  let theFileExtension = takeExtension sourcePath
  let isItThere = doesFileExist sourcePath
  isItThere <- doesFileExist sourcePath
  -- We test if the file does exist and from specific extensions we presume it's basically
  -- a flat text that can be easily turned into an html file by adding html tags at the top
  -- and bottom.
  -- TODO: all these possible extensions should probably be defined in a config file
  -- not hard coded inside the code here:
  if (isItThere && (theFileExtension == ".txt"
                                     || theFileExtension == ".md"
                                     || theFileExtension == ".conf")) then do
    -- then read the content of the text file
    content <- readFile sourcePath
--    let newContent = treat_content content
    -- Create a new name for the text file (e.g., append ".html")
--    let newName = (takeBaseName sourcePath) ++ ".html"
--    let newName = dropExtension sourcePath ++ ".html"
--    let newFile = destPath </> newName
--    let newFile = (dropExtension destPath) ++ ".html"
    let newFile = destPath ++ ".html" -- I just double up the extension
                                      -- that way I retain the information about
                                      -- what was the original type of the file
    -- Write the content to the new file
--    putStrLn ("We are working on this file: " ++ newName)
--    withFile newFile WriteMode $ \handle -> do
    withFile newFile WriteMode $ \handle -> do
    -- Write the prepend string, then the original content,
    -- then the append string
--      thisNavStr <- navStr destPath
      let thisNavStr = navStr destPath
      hPutStr handle (prependStr ++ "\n" ++ thisNavStr ++ "\n" ++ "<h1>" ++ destPath ++ "</h1>" ++ "\n" ++ content ++ "\n" ++ appendStr)
    return [newFile]
  else do
    return []

{-
Adjust the relative path to the nav.html file when including it in the page
via the object tag.
We are probably going to use "splitDirectories"
splitDirectories :: FilePath -> [FilePath]
https://hackage.haskell.org/package/filepath-1.5.4.0/docs/System-FilePath.html#v:splitDirectories
https://hackage.haskell.org/package/filepath-1.5.4.0/docs/System-FilePath.html

The idea I have for now, is to count the number of subfolder in the sourcePath (or
destPath since they should be the same), and place an equal number of "../" in
the relaive path to "nav.html" in the data field of the object tag in navStr.

-}


-- ---------------------------
-- navStr:
-- Returns a string to be placed into the created html files,
-- so that they display the navbar once they are loaded into the browser.
-- The whole point of this function here is to create the correct relative path
-- ../../.. to the nav.html file. 
-- The next line is the old definition when I was not caring about the relative path yet.
-- navStr = "<object type=\"text/html\" data=\"nav.html\"></object>"
navStr :: FilePath -> String
navStr theFilePath = do
  -- https://hackage.haskell.org/package/filepath-1.5.4.0/docs/src/System.FilePath.Posix.html#splitDirectories
  -- splitDirectories :: FilePath -> [FilePath]
  let subDirLevelsList = splitDirectories theFilePath
--  numberOfLevels <- length subDirLevelsList
  let numberOfLevels = (length subDirLevelsList) - 2 -- 1 for the filename + 1 for the root folder
  let relativeDotPath = concat (replicate numberOfLevels "../")
--  let relativeDotPath = replicate numberOfLevels "../"
--  putStrLn ("number of levels: relativeDotPath: " ++ relativeDotPath) 
--  return ("<object type=\"text/html\" data=\"" ++ relativeDotPath ++ "nav.html\"></object>")
  "<object type=\"text/html\" data=\"" ++ relativeDotPath ++ "nav.html\" width=\"600\"></object>"
-- TODO: ^ the hight of the object should be defined here
-- do depend on the number of lines/links present in the nav.html file.
-- That way I don't have to
-- schroll up and down to see all links.
--  return (concat (unwords ["testRELATIVE"]))
--  "aStringTest"


appendStr = "</pre>\n\
            \</body>\n\
            \</html>"

-- weblinksStyle variable is not used so far:
weblinksStyle =
            "a:link {\n\
               \color: #ff0000;\n\
               \text-decoration: none;\n\
               \border-bottom: 1px solid;\n\
            \}\n\
            \a:visited {\n\
               \color: #ff00ff;\n\
            \}\n\
            \a:hover {\n\
              \color: #00ff00;\n\
              \border-bottom: none;\n\
            \}\n\
              \a:active {\n\
              \color: #00ffff;\n\
            \}"


prependStr = "<!DOCTYPE html>\n\
             \<html>\n\
             \<header>\n\
             \  <style>\n\
             \    body {\n\
             \      background-color: #101010;\n\
             \      color: #FFBB00\n\
             \    }\n\
             \    a:link {\n\
             \      color: #ffccaa;\n\
             \      text-decoration: none;\n\
             \      border-bottom: 1px solid;\n\
             \    }\n\
             \    a:visited {\n\
             \      color: #cc00cc;\n\
             \    }\n\
             \    a:active {\n\
             \      color: #00ffff;\n\
             \    }\n\
             \  </style>\n\
             \</header>\n\
             \<body>\n\
             \<pre>"



treat_content :: String -> String
treat_content content = "To be built"
  




--addHtml :: String -> String
--addHtml content =
--  return (prependStr ++ "\n" ++ content ++ "\n" ++ appendStr)

addHtml :: String -> String
addHtml content = prependStr ++ "\n" ++ content ++ "\n" ++ appendStr

addHyperLinks :: [String] -> [String]
addHyperLinks content =
  let functionToApply = \str -> let cleanedPath = removeRootDir str in "<a href=\"" ++ cleanedPath ++ "\" target=\"_top\">" ++ cleanedPath ++ "</a>"
--  map (\str -> "<a href=\"" ++ str ++ "\">" ++ str ++ "</a>") content
--  map (\str -> functionToApply str) content
  in map functionToApply content


removeRootDir :: FilePath -> FilePath
removeRootDir aFilePath =
  let components = splitPath aFilePath
      -- Drop the first component
      remainingComponents = drop 1 components
  in joinPath remainingComponents


-- ==========================================================
-- ==========================================================
-- MAIN:
main :: IO ()
main = do
--  let filePath = "test.txt"  
--  let filePath = "simpletextfile.txt"
  args <- getArgs
  case args of
    [] -> putStrLn "No argument provided."
    (arg:_) -> do
      let filePath = arg
      let destDir = filePath ++ "_webified_mirror"
      createDirectoryIfMissing True destDir
      filesList <- processDirectory filePath destDir
--      let linkedFileList = addHyperLinks (unlines filesList)
--      let htmlFilesList = addHtml linkedFileList
      let linkedFilesList = addHyperLinks filesList
--      let htmlFilesList = addHtml linkedFilesList
      let htmlFilesList = addHtml (unlines linkedFilesList)
--      let htmlFilesList = addHtml (unlines filesList)
      writeFile (destDir ++ "/" ++ "nav.html") htmlFilesList
--      writeFile (destDir ++ "/" ++ "nav.html") (unlines files)
      putStrLn $ "List of files written to " ++ "nav.html"
  -- catch any IOException
--      catch(modifyFile filePath prependStr appendStr) handleError
--      putStrLn "File has been modified."
      putStrLn "Processing complete."
  -- putStrLn prependStr
  -- putStrLn appendStr




-- Error handling function
handleError :: IOException -> IO ()
handleError e = putStrLn $ "An error occured: " ++ show e



-- NOT USED ANYMORE:
-- Function to prepend and append strings to a file
modifyFile :: FilePath -> String -> String -> IO ()
modifyFile filePath prependStr appendStr = do
  -- Read the existing content of the file
  content <- readFile filePath
  putStrLn content
  -- Open the file for writing (this will truncate the file)
  withFile filePath WriteMode $ \handle -> do
    -- Write the prepend string, then the original content, then the append string
    hPutStr handle (prependStr ++ "\n" ++ content ++ "\n" ++ appendStr)


